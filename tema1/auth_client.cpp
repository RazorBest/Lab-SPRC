/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <vector>
#include <string>
#include <unordered_map>

#include "auth.h"

struct command {
    char uid[16];
    Operation operation;
    char resource[256];
};

struct token_data {
    std::string token;
    int life;
};

std::unordered_map<std::string, std::string> token_db;
std::unordered_map<std::string, token_data> regen_db;


CLIENT* init_client(const char *host) {
	CLIENT *clnt;

	clnt = clnt_create (host, REQUESTAUTH_PROG, REQUESTAUTH_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror(host);
		exit (1);
	}

    return clnt;
}

void close_client(CLIENT *clnt) {
    clnt_destroy(clnt);
}

// Calls the REQUESTAUTH RPC procedure
int request_auth(CLIENT *clnt, char *uid, char *token) {
	auth_output *result;

    // RPC call
	result = requestauth_1(&uid, clnt);
	if (result == (auth_output *) NULL) {
		clnt_perror (clnt, "call failed");
        return -1;
	}

    if (result->status == S_USER_NOT_FOUND) {
        token[0] = '\0';
        return result->status;
    }

    strcpy(token, result->auth_token);

    return result->status;
}

// Calls the APPROVETOKEN RPC procedure
approve_output* approve_token(CLIENT *clnt, char *uid, char *auth_token) {
	approve_input input;
	approve_output *result;

    memcpy(input.id, uid, 16);
    memcpy(input.auth_token, auth_token, 16);

    // RPC call
	result = approvetoken_1(&input, clnt);
	if (result == (approve_output *) NULL) {
		clnt_perror (clnt, "call failed");
	}

    if (result->status == S_REQUEST_DENIED) {
        return NULL;
    }

    return result;
}

// Calls the REQUESTACCESS RPC procedure
access_output* request_access(CLIENT *clnt, const char *uid, 
        approve_output *app_out, int regen) {

	access_input input;
	access_output *result;

    memcpy(input.id, uid, 16);
    memcpy(input.auth_token, app_out->auth_token, 16);
    input.permissions = app_out->permissions;
    memcpy(input.signature, app_out->signature, 64);
    input.regen = regen;

    // RPC call
	result = requestaccess_1(&input, clnt);
	if (result == (access_output *) NULL) {
		clnt_perror (clnt, "call failed");
        return NULL;
	}

    if (result->status == S_REQUEST_DENIED) {
        return NULL;
    }

    return result;
}

// Calls the VALIDATEACTION RPC procedure
status_code validate_action(CLIENT *clnt, char *uid, Operation operation,
        char *resource) {
	validate_input input;
	status_code  *result;

    // If the token expired and we have a refresh token
    if (regen_db.count(uid) > 0 && regen_db[uid].life == 0) {
        approve_output app_out;
        access_output *acc_out;
        const char * token = regen_db[uid].token.c_str();

        memcpy(app_out.auth_token, token, 16);
        app_out.permissions = (char*)malloc(1);

        acc_out = request_access(clnt, uid, &app_out, 1);

        regen_db[uid] = {
            acc_out->regen_token,
            acc_out->life
        };
        token_db[uid] = acc_out->access_token;
    }


    input.operation = operation;
    input.resource = (char*)malloc(strlen(resource) + 1);
    strcpy(input.resource, resource);

    // If we have an access token for the given user
    if (token_db.count(uid) > 0) {
        const char *token = token_db[uid].c_str();
        memcpy(input.access_token, token, 16);
    } else {
        memset(input.access_token, 16, 0);
    }

    // RPC call
	result = validateaction_1(&input, clnt);
	if (result == (status_code *) NULL) {
		clnt_perror (clnt, "call failed");
	}

    if (regen_db.count(uid) > 0) {
        regen_db[uid].life--;
    }

    return *result;
}

// Reads the commands list from a file, stores them in an array and returns them
std::vector<command> load_commands(const char *path) {
    std::vector<command> commands;
    FILE *fin = fopen(path, "r");
    char buf[512];
    std::unordered_map<std::string, Operation> op_map = {
        {"REQUEST", REQUEST},
        {"READ", READ},
        {"INSERT", INSERT},
        {"MODIFY", MODIFY},
        {"DELETE", DELETE},
        {"EXECUTE", EXECUTE}
    };

    if (fin == NULL) {
        return {};
    }

    while(fgets(buf, sizeof(buf), fin)) {
        command cmd;
        int len = strlen(buf);
        if (buf[len - 1] == '\n') {
            buf[len - 1] = '\0';
        }

        char *word;

        word = strtok(buf, ",");
        strcpy(cmd.uid, word);

        word = strtok(NULL, ",");
        if (op_map.count(word) > 0) {
            cmd.operation = op_map[word];
        } else {
            cmd.operation = INTERCONTINENTAL_BALLISTIC_MISSILE;
        }

        word = strtok(NULL, ",");
        strcpy(cmd.resource, word);

        commands.push_back(cmd);
    }

    return commands;
}

// Handles the state of the client by applying a command
void handle_command(CLIENT *clnt, command &cmd) {
    char auth_token[16];
    approve_output *appr_out;
    access_output *acc_out;
    int status;
    int need_regen = 0;

    switch(cmd.operation) {
    case REQUEST:
        status = request_auth(clnt, cmd.uid, auth_token); 
        if (status == S_USER_NOT_FOUND) {
            printf("USER_NOT_FOUND\n");
            break;
        }
        appr_out = approve_token(clnt, cmd.uid, auth_token);
        if (appr_out == NULL) {
            printf("REQUEST_DENIED\n");
            break;
        }
        if (cmd.resource[0] == '0') {
            need_regen = 0;
            acc_out = request_access(clnt, cmd.uid, appr_out, 0);
        } else {
            need_regen = 1;
            acc_out = request_access(clnt, cmd.uid, appr_out, 1);
        }
        if (acc_out == NULL) {
            printf("REQUEST_DENIED\n");
            break;
        }
        if (need_regen) {
            printf("%s -> %s,%s\n", auth_token, acc_out->access_token,
                acc_out->regen_token);
            regen_db[cmd.uid] = {
                acc_out->regen_token,
                acc_out->life,
            };

        } else {
            printf("%s -> %s\n", auth_token, acc_out->access_token);
        }

        token_db[cmd.uid] = acc_out->access_token;
        break;

    default:
        status = validate_action(clnt, cmd.uid, cmd.operation, cmd.resource);

        if (status == S_PERMISSION_DENIED) {
            printf("PERMISSION_DENIED\n");
            break;
        }

        if (status == S_TOKEN_EXPIRED) {
            printf("TOKEN_EXPIRED\n");
            break;
        }
        if (status == S_OPERATION_NOT_PERMITTED) {
            printf("OPERATION_NOT_PERMITTED\n");
            break;
        }
        if (status == S_RESOURCE_NOT_FOUND) {
            printf("RESOURCE_NOT_FOUND\n");
            break;
        }

        printf("PERMISSION_GRANTED\n");
    }
}

void run_commands(CLIENT *clnt, std::vector<command> &commands) {
    for (auto &command : commands) {
        handle_command(clnt, command);
    }
}


int main (int argc, const char *argv[]) {
	const char *host;

	if (argc < 3) {
		printf ("usage: %s server_host input_file\n", argv[0]);
		exit(1);
	}
	host = argv[1];
    CLIENT *clnt = init_client(host);

    auto commands = load_commands(argv[2]);
    run_commands(clnt, commands);

    close_client(clnt);

    exit(0);
}
