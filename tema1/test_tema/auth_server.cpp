/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <string>
#include <vector>
#include <unordered_set>
#include <unordered_map>

#include "./auth.h"
#include "./token.h"
#include "./globals.h"

std::unordered_map<Operation, const char*> op_to_str = {
    {READ, "READ"},
    {INSERT, "INSERT"},
    {MODIFY, "MODIFY"},
    {DELETE, "DELETE"},
    {EXECUTE, "EXECUTE"},
    {INTERCONTINENTAL_BALLISTIC_MISSILE, "11111"}
};

void hash(const u_char *str, int len, u_char *res, int hash_len) {
    unsigned long hash = 5381;
    int c;

    memset(res, 0, hash_len * sizeof(*res));

    for (int i = 0; i < len; i++) {
        c = str[i];
        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
        res[i % hash_len] += hash;
    }

    for (int i = 0; i < hash_len; i++) {
        if (res[i] == 0) {
            res[i] = 0xff;
        }
    }
}

void sign_token(approve_output *data) {
    char buf[512];
    int len = 0;

    memcpy(buf + len, data->auth_token, 16);
    len += 16;

    memcpy(buf + len, data->permissions, strlen(data->permissions));
    len += strlen(data->permissions);

    hash((u_char*)buf, len, (u_char*)data->signature, 64);
}

int verify_signature(access_input *data) {
    char buf[512];
    u_char expected_signature[64];
    int len = 0;

    memcpy(buf + len, data->auth_token, 16);
    len += 16;

    memcpy(buf + len, data->permissions, strlen(data->permissions));
    len += strlen(data->permissions);

    hash((u_char*)buf, len, (u_char*)expected_signature, 64);

    return memcmp(data->signature, expected_signature, 64) == 0;
}


int user_exists(const char *uid) {
    return globals.users.count(uid) > 0;
}

int check_auth_token(const char *uid, const char *token) {
    char *expected = generate_access_token(uid);
    int success = 0;

    if (strcmp(expected, token) == 0) {
        success = 1;
    }

    free(expected);

    return success;
}

char* get_permissions() {
    char *perm_str;
    std::string permissions = globals.approve_queue.front();
    globals.approve_queue.pop();
    int len;

    len = permissions.size() + 1;
    perm_str = (char*) malloc(len);
    strncpy(perm_str, permissions.c_str(), len - 1);
    perm_str[len - 1] = '\0';

    return perm_str;
}

// Gets a string of permission characters and returns a int of permission flags
// The string of permission can look like this: "XRDM"
int convert_to_perm_flags(const std::string &permissions) {
    const std::unordered_map<char, Operation> perm_char_to_int = {
        {'R', READ},
        {'I', INSERT},
        {'M', MODIFY},
        {'D', DELETE},
        {'X', EXECUTE}
    };
    int perm_flags = 0;

    for (char c : permissions) {
        const auto &it = perm_char_to_int.find(c);

        if (it == perm_char_to_int.end()) {
            continue;
        }

        perm_flags |= it->second; 
    }

    return perm_flags;
}

std::vector<file_permission> parse_permissions(const char *perm_str) {
    std::vector<file_permission> perms;
    std::string resource;
    std::string permission;
    int is_resource = 1;
    int start = 0;

    int i;
    for (i = 0; perm_str[i]; i++) {
        if (perm_str[i] != ',') {
            continue;
        }

        if (is_resource) {
            // Extract the resource word
            resource = std::string(perm_str + start, i - start);
        } else {
            // Extract the permissions word
            std::string permission(perm_str + start, i - start);
            int perm_flags = convert_to_perm_flags(permission); 

            // Add the parsed permission to the final vector
            perms.emplace_back(resource, perm_flags);
        }

        start = i + 1;
        is_resource = !is_resource;
    }

    if (start < i && !is_resource) {
        // Extract the permissions word
        std::string permission(perm_str + start, i - start);
        int perm_flags = convert_to_perm_flags(permission); 

        // Add the parsed permission to the final vector
        perms.emplace_back(resource, perm_flags);

    }

    return perms;
}


auth_output* requestauth_1_svc(char **argp, struct svc_req *rqstp) {
	static auth_output result;
    memset(&result, 0, sizeof(result));
    const char *uid = *argp;

    printf("BEGIN %s AUTHZ\n", uid);

    if (user_exists(uid)) {
        result.status = S_SUCCESS;
        char *token = generate_access_token(uid);
        memcpy(result.auth_token, token, 16);
        free(token);
        printf("  RequestToken = %s\n", result.auth_token);
    } else {
        result.status = S_USER_NOT_FOUND;
    }

	return &result;
}

approve_output * approvetoken_1_svc(approve_input *argp, struct svc_req *rqstp) {
	static approve_output result;
    memset(&result, 0, sizeof(result));
    const char *uid = argp->id;
    const char *auth_token = argp->auth_token;

    memcpy(result.auth_token, auth_token, 16);

    if (!user_exists(uid)) {
        result.status = S_REQUEST_DENIED;
        return &result;
    }

    result.permissions = get_permissions();

    // If the user rejects any rights
    if (strcmp(result.permissions, "*,-") == 0) {
        result.status = S_REQUEST_DENIED;

        return &result;
    }

    sign_token(&result);
    result.status = S_SUCCESS;

    return &result;
}


access_output * requestaccess_1_svc(access_input *argp, struct svc_req *rqstp) {
	static access_output  result;
    memset(&result, 0, sizeof(result));

    const char *uid = argp->id;
    const char *perm_str = argp->permissions;
    const u_char *signature = argp->signature;
    const char *auth_token = argp->auth_token;
    std::vector<file_permission> perms = parse_permissions(perm_str);

    // If regen is requested
    if (globals.regen_db.count(auth_token) > 0) {
        printf("BEGIN %s AUTHZ REFRESH\n", uid);

        auto old_token = globals.regen_db[auth_token];
        char* new_token = generate_access_token(auth_token);
        char* regen_token = generate_access_token(new_token);

        // Update the database with the new tokens
        globals.token_db[new_token] = globals.token_db[old_token];
        globals.token_db[new_token].life = globals.token_ttl;
        globals.token_db.erase(old_token);

        globals.regen_db.erase(auth_token);
        globals.regen_db[regen_token] = new_token;

        memcpy(result.regen_token, regen_token, 16);
        result.status = S_SUCCESS;
        memcpy(result.access_token, new_token, 16);
        result.life = globals.token_ttl;

        printf("  AccessToken = %s\n", new_token);
        printf("  RefreshToken = %s\n", result.regen_token);

        free(new_token);
        free(regen_token);

        return &result;
    }

    if(!verify_signature(argp)) {
        result.status = S_REQUEST_DENIED;
        return &result;
    }

    perms = parse_permissions(perm_str);

    if (perms.size() == 0) {
        result.status = S_REQUEST_DENIED;
        return &result;
    }

    char *access_token = generate_access_token(auth_token);
    // If a refresh token was requested
    if (argp->regen) {
        char *regen_token = generate_access_token(access_token);
        memcpy(result.regen_token, regen_token, 16);
        globals.regen_db[regen_token] = access_token;
        free(regen_token);
    }

    globals.token_db[access_token] = {
        std::move(perms),
        globals.token_ttl
    };

    result.status = S_SUCCESS;
    memcpy(result.access_token, access_token, 16);
    result.life = globals.token_ttl;

    printf("  AccessToken = %s\n", access_token);
    if (argp->regen) {
        printf("  RefreshToken = %s\n", result.regen_token);
    }

	return &result;
}

status_code * validateaction_1_svc(validate_input *argp, struct svc_req *rqstp) {
	static status_code  result;
    memset(&result, 0, sizeof(result));
    const char *access_token = argp->access_token;
    Operation operation = argp->operation;
    const char *resource = argp->resource;

    // Search for the access token
    const auto &it = globals.token_db.find(access_token);
    // If the token is not found
    if (it == globals.token_db.end()) {
        printf("DENY (%s,%s,,0)\n", op_to_str[operation], resource);
        result = S_PERMISSION_DENIED;
        return &result;
    }

    token_data &token = it->second;

    // If the token expired
    if (token.life <= 0) {
        printf("DENY (%s,%s,,0)\n", op_to_str[operation], resource);
        result = S_TOKEN_EXPIRED;
        return &result;
    }

    token.life--;

    // Check if resource exists
    const auto &file_it = globals.resource_db.find(resource);
    if (file_it == globals.resource_db.end()) {
        printf("DENY (%s,%s,%s,%d)\n", op_to_str[operation], resource,
            access_token, token.life);
        result = S_RESOURCE_NOT_FOUND;
        return &result;
    }

    // Check for permissions
    bool permitted = false;
    for (auto &perm : token.perms) {
        if (perm.path == resource) {
            if (perm.perm_flags & operation) {
                permitted = true;
            }
            break;
        }
    }

    if (!permitted) {
        printf("DENY (%s,%s,%s,%d)\n", op_to_str[operation],
            resource, access_token, token.life);
        result = S_OPERATION_NOT_PERMITTED;
        return &result;
    }

    printf("PERMIT (%s,%s,%s,%d)\n", op_to_str[operation],
        resource, access_token, token.life);
    result = S_PERMISSION_GRANTED;

	return &result;
}
